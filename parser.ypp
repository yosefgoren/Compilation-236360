%{
	int yylex();
	void yyerror(const char* s);
	#include "stdio.h"
	#include "Symtab.hpp"
	#include "AuxTypes.hpp" 
	#include "hw3_output.hpp"
	#include "bp.hpp"
	#include "assert.h"
	#include <iostream>
	#include <algorithm>
	#include <set>
	extern int yylineno;

	//#define MYDB
	#ifdef MYDB
		#define YYERROR_VERBOSE 1
		#define YYDEBUG 1
		extern int yydebug;
	#endif

	SimpleSymtab symtab;
	using namespace std;

	#define check(assertion, error) do{if(!(assertion)){error; exit(1);}}while(false);

	static int loop_depth;
	
	bool isNumeralType(ExpType type){
		return type == INT_EXP || type == BYTE_EXP;
	}
	bool canImplicitCast(ExpType source_type, ExpType dst_type){
		return (source_type == dst_type)
			|| (source_type == BYTE_EXP && dst_type == INT_EXP);
	}
	bool canExplicitCast(ExpType source_type, ExpType dst_type){
		if(source_type == dst_type)
			return true;
		return isNumeralType(source_type) && isNumeralType(dst_type);
	}

	void checkMismatch(ExpType source_type, ExpType dst_type){
		check(canImplicitCast(source_type, dst_type), output::errorMismatch(yylineno));
	}
	
	void checkBool(ExpType type) {
		checkMismatch(type, BOOL_EXP);
	}

	void checkNumeralType(ExpType type){
		check(isNumeralType(type), output::errorMismatch(yylineno));
	}

	ExpType maxNumeralType(ExpType first_operand_type, ExpType second_operand_type){
		return first_operand_type == INT_EXP ? INT_EXP : second_operand_type;
	}

	void checkFuncDec(const string& func_id, const std::vector<Parameter>& parameters){
		std::set<std::string> tmp_params_set;
		for(auto it = parameters.rbegin(); it != parameters.rend(); ++it){
			auto param = *it;
			//check that the new parameter identifiers don't conflict with the id of the new function:
			check(func_id != param.id, output::errorDef(param.line_of_origin, param.id));
			//check that the new parameter identifiers dont confilict with existing ones: 
			check(symtab.declarableValidId(param.id), output::errorDef(param.line_of_origin, param.id));
			//check that there are not conflitcts between the new identifiers:
			check(tmp_params_set.count(param.id) == 0, output::errorDef(param.line_of_origin, param.id));
			tmp_params_set.insert(param.id);
		}
	}

	void checkPrototypeMismatch(const string& func_id, const std::vector<Expression*>& reverse_exp_list_in_call){
		std::vector<ExpType> exp_types_required = symtab.getFunctionType(func_id).getParameterTypes();
		//TODO: add something to remember the line of each expression so we can add the correct 
		// 		line of the expression to this error (something like 'line_of_origin').
		auto required_types_it = exp_types_required.begin();
		for(auto called_exp_it = reverse_exp_list_in_call.rbegin();
				called_exp_it != reverse_exp_list_in_call.rend(); ++called_exp_it){
			
			ExpType called_type = (*called_exp_it)->type;
			if(required_types_it == exp_types_required.end() || !canImplicitCast(called_type, *required_types_it)){
				output::errorPrototypeMismatch(yylineno, func_id, ExpTypeStringVector(exp_types_required, true));
				exit(1);
			}
			++required_types_it;
		}
		if(required_types_it != exp_types_required.end()){
				output::errorPrototypeMismatch(yylineno, func_id, ExpTypeStringVector(exp_types_required, true));
				exit(1);			
		}
	}
	void checkMainMissing(){
		if (symtab.callableValidId("main")) {
			const FunctionType& func = symtab.getFunctionType("main");
			if (func.return_type != VOID_EXP || !func.getParameterTypes().empty()){
				output::errorMainMissing();
				exit(1);
			} 
		}else {
			output::errorMainMissing();
			exit(1);
		}
	}

	void checkByteTooLarge(int b) {
		if (b > 255 || b < 0) {
			output::errorByteTooLarge(yylineno, to_string(b));
			exit(1);
		}
	}

	CodeBuffer& cb = CodeBuffer::instance();
%}

%union{
	//lexer proivided fields:
	string* id;
	string* string_literal;
	int number_literal;
	
	//parser metadata fields:
	int line_number;
	bool is_const;
	
	Binop binop;
	Relop relop;
	ExpType exp_type;

	std::vector<Expression*>* exp_list;
	std::vector<Parameter>* formals_list;
	std::vector<Backpatch>* nextlist;
	std::string* label;
	
	Expression* expression;
	BranchBlock* branch_block;
	NumericExp* numeric_exp;
	Parameter* formal;

	DecInfo dec_info;
};

%nonassoc INT VOID BYTE B BOOL CONST
%token TRUE FALSE
%token RETURN WHILE BREAK CONTINUE SC

%token STRING
%token COMMA
%token <id> ID
%token <number_literal> NUM

%right ASSIGN
%left OR
%left AND
%left <relop> RELOP
%left <binop> BINOP
%right NOT

%left LPAREN RPAREN LBRACE RBRACE
%right IF
%token ELSE

%type <expression> Exp NumericExp BoolExp Call
%type <exp_type> RetType Type
%type <exp_list> ExpList
%type <formals_list> Formals FormalsList
%type <line_number> LineCapture
%type <is_const> TypeAnnotation
%type <dec_info> VarDecStart
%type <label> Label
%type <nextlist> Statements Statement OpenStatment ClosedStatment SimpleStatement Block
%type <branch_block> IfStart WhileStart

%%

Program:			Funcs
					;
OpenScope:			{symtab.pushScope();};
CloseScope:			{symtab.popScope();};
OpenLoop:			{++loop_depth;};
CloseLoop:			{--loop_depth;};

Block:				LBRACE OpenScope Statements RBRACE CloseScope {
						$$ = $3;
					}
					;

Funcs:				FuncDecl Funcs
					|
					;
FuncDecl:			RetType ID {check(symtab.declarableValidId(*$2), output::errorDef(yylineno, *$2));}
					LPAREN Formals {	
						checkFuncDec(*$2, *$5);
						symtab.declareFunc(*$2, $1, $5);
						//TODO: emit decleration of this function.
						cb.emit("%sp = alloca [50 x i32]");
					} RPAREN LBRACE Statements RBRACE {
						symtab.finishFunc();
						//TODO: emit end of func (rbrace)
					}
					;
RetType:			Type {$$ = $1;}
					|VOID {$$ = VOID_EXP;}
					;
Formals:			{$$ = new std::vector<Parameter>();}
					|FormalsList {$$ = $1;} 

FormalsList:		TypeAnnotation Type ID {$$ = new std::vector<Parameter>(); $$->push_back(Parameter(*$3, $2, yylineno, $1)); delete $3;}
					|TypeAnnotation Type ID LineCapture COMMA FormalsList {$$ = $6; $$->push_back(Parameter(*$3, $2, $4, $1)); delete $3;}
					;
LineCapture:		{$$ = yylineno;};

Statements:			Statement {$$ = $1;}
					|Statements Label Statement {cb.bpatch(*$1, *$2); $$ = $3;}
					;
Call:				ID LPAREN ExpList RPAREN {
						check(symtab.callableValidId(*$1), output::errorUndefFunc(yylineno, *$1));
						checkPrototypeMismatch(*$1, *$3);
						$$ = cb.emitFunctionCall(*$1, *$3);
						delete $1;
					}
					|ID LPAREN RPAREN {
						check(symtab.callableValidId(*$1), output::errorUndefFunc(yylineno, *$1));
						//there are no arguments used in the call so std::vector is empty:
						std::vector<Expression*> call_arg_types = {};
						checkPrototypeMismatch(*$1, call_arg_types);
						$$ = cb.emitFunctionCall(*$1, std::vector<Expression*>());
						delete $1;	
					}
					;
ExpList:			Exp {$$ = new std::vector<Expression*>(); $$->push_back($1);}
					|Exp COMMA ExpList {$$ = $3; $$->push_back($1);}
					;
Type:				INT {$$ = INT_EXP;}
					|BYTE {$$ = BYTE_EXP;}
					|BOOL {$$ = BOOL_EXP;}
					;
TypeAnnotation:		CONST {$$ = true;}
					| {$$ = false;}
					;	
Exp:				LPAREN Exp RPAREN {$$ = $2;}
					| Call {$$ = $1;}
					| ID {
						check(symtab.rvalValidId(*$1), output::errorUndef(yylineno, *$1));
						$$ = cb.emitLoadVar(*$1);
						delete $1;
					}
					| STRING {$$ = new StrExp();}
					| LPAREN Type RPAREN Exp {
						check(canExplicitCast($4->type, $2), output::errorMismatch(yylineno));
						$$ = $4;
						$$->type = $2;//TODO - this is not a real cast & should be handled better.
					}
					| NumericExp
					| BoolExp
					;

NumericExp:			Exp BINOP Exp {
						checkNumeralType($1->type);
						auto numeric_e1 = dynamic_cast<NumericExp*>($1);
						assert(numeric_e1);
						checkNumeralType($3->type);
						auto numeric_e2 = dynamic_cast<NumericExp*>($3);
						assert(numeric_e2);

						string rvalue_exp = cb.binopRvalFormat(numeric_e1->reg, numeric_e2->reg, $1->type, $2);
						$$ = new NumericExp(maxNumeralType($1->type, $3->type), rvalue_exp);
						delete $1;
						delete $3;
					}
					| NUM {$$ = new NumericExp(INT_EXP, cb.literalRvalFormat($1, INT_EXP));}
					| NUM B {
						checkByteTooLarge($1);
						$$ = new NumericExp(BYTE_EXP, cb.literalRvalFormat($1, BYTE_EXP));
					}
					;
Label: 				{
						Backpatch bp(cb.emit("br label @"), FIRST);
						$$ = new string(cb.genLabel("parse_label"));
						cb.bpatch(cb.makelist(bp), *$$);
					}
					;

BoolExp: 			Exp AND Label Exp {
						checkMismatch($1->type, BOOL_EXP);
						checkMismatch($4->type, BOOL_EXP);
						BoolExp* exp1 = dynamic_cast<BoolExp*>($1);
						assert(exp1);
						BoolExp* exp2 = dynamic_cast<BoolExp*>($4);
						assert(exp2);
						BoolExp* res_exp = new BoolExp();

						cb.bpatch(exp1->truelist, *$3);
						res_exp->falselist = cb.merge(exp1->falselist, exp2->falselist);
						res_exp->truelist = exp2->truelist;
						$$ = res_exp;
						delete $1;
						delete $3;
						delete $4;
					}
		 			|Exp OR Label Exp {
						checkMismatch($1->type, BOOL_EXP);
						checkMismatch($4->type, BOOL_EXP);
						BoolExp* exp1 = dynamic_cast<BoolExp*>($1);
						assert(exp1);
						BoolExp* exp2 = dynamic_cast<BoolExp*>($4);
						assert(exp2);
						BoolExp* res_exp = new BoolExp();

						cb.bpatch(exp1->falselist, *$3);
						res_exp->truelist = cb.merge(exp1->truelist, exp2->truelist);
						res_exp->falselist = exp2->falselist;
						
						$$ = res_exp;
						delete $1;
						delete $3;
						delete $4;
					}
					| Exp RELOP Exp {
						check(isNumeralType($1->type) && isNumeralType($3->type), output::errorMismatch(yylineno));
						NumericExp* exp1 = dynamic_cast<NumericExp*>($1);
						assert(exp1);
						NumericExp* exp2 = dynamic_cast<NumericExp*>($3);
						assert(exp2);
						
						ExpType operand_type = maxNumeralType(exp1->type, exp2->type);
						std::string cond_rval = cb.relopRvalFormat(exp1->reg, exp2->reg, operand_type, $2);
						std::string cond_reg = cb.getFreshReg();
						cb.emitRegDecl(cond_reg, cond_rval);
						int br_address = cb.emit("br i1 "+cond_reg+", label @, label @");
						
						BoolExp* res_exp = new BoolExp();
						res_exp->truelist = cb.makelist(Backpatch(br_address, FIRST));
						res_exp->falselist = cb.makelist(Backpatch(br_address, SECOND));
						
						$$ = res_exp;
						delete $1;
						delete $3;
					}
					| NOT Exp {
						checkMismatch($2->type, BOOL_EXP);
						BoolExp* exp = dynamic_cast<BoolExp*>($2);
						assert(exp);
						auto tmp = exp->truelist;
						exp->truelist = exp->falselist;
						exp->falselist = tmp;
						$$ = exp;
					}
					| TRUE {
						int position = cb.emit("br label @");
						Backpatch bp_details(position, FIRST);
						BoolExp* exp = new BoolExp();
						exp->truelist = CodeBuffer::makelist(bp_details);
						$$ = exp;
					}
					| FALSE {
						int position = cb.emit("br label @");
						Backpatch bp_details(position, FIRST);
						BoolExp* exp = new BoolExp();
						exp->falselist = CodeBuffer::makelist(bp_details);
						$$ = exp;
					}
					;

Statement:			OpenStatment {$$ = $1;}
					| ClosedStatment {$$ = $1;}
					;
					
OpenStatment:		IfStart OpenScope Label Statement CloseScope {
						cb.bpatch($1->truelist, *$3);

						$$ = new std::vector<Backpatch>(cb.merge($1->falselist, *$4));
						delete $1; delete $3; delete $4;
					}
					| IfStart OpenScope Label ClosedStatment CloseScope ELSE OpenScope Label OpenStatment CloseScope {
						cb.bpatch($1->truelist, *$3);
						cb.bpatch($1->falselist, *$8);
						$$ = new std::vector<Backpatch>(cb.merge(*$4, *$9));
						delete $1; delete $3; delete $4; delete $8; delete $9;
					}
					| WhileStart OpenLoop OpenScope Label OpenStatment CloseScope CloseLoop {
						cb.bpatch($1->truelist, *$4);
						cb.bpatch(*$5, $1->cond_label);
						$$ = new std::vector<Backpatch>($1->falselist);
						delete $1; delete $4; delete $5;
					}
					;

ClosedStatment:		SimpleStatement {$$ = $1;}
					| IfStart OpenScope Label ClosedStatment CloseScope ELSE OpenScope Label ClosedStatment CloseScope {
						cb.bpatch($1->truelist, *$3);
						cb.bpatch($1->falselist, *$8);
						$$ = new std::vector<Backpatch>(cb.merge(*$4, *$9));
						delete $1; delete $3; delete $4; delete $8; delete $9;
					}
					| WhileStart OpenLoop OpenScope Label ClosedStatment CloseScope CloseLoop {
						cb.bpatch($1->truelist, *$4);
						cb.bpatch(*$5, $1->cond_label);
						$$ = new std::vector<Backpatch>($1->falselist);
						delete $1; delete $4; delete $5;
					}
					;
IfStart:			IF LPAREN Label Exp {checkBool($4->type);} RPAREN {
						$$ = new BranchBlock(*$3, $4);
						delete $3; delete $4;
					};	
WhileStart:			WHILE LPAREN Label Exp {checkBool($4->type);} RPAREN {
						$$ = new BranchBlock(*$3, $4);
						delete $3; delete $4;
					};

SimpleStatement:	Block {$$ = $1;}
					|VarDecStart SC {
						check(!$1.is_const, output::errorConstDef(yylineno));
						symtab.declareVar(*$1.id, $1.raw_type, $1.is_const);
						cb.emitStoreVar(*$1.id, 0);
						$$ = new std::vector<Backpatch>(cb.makeEmptyList());
						delete $1.id;
					}
					|VarDecStart ASSIGN Exp SC {
						checkMismatch($3->type, $1.raw_type);
						symtab.declareVar(*$1.id, $1.raw_type, $1.is_const);
						cb.emitStoreVar(*$1.id, $3);	
						$$ = new std::vector<Backpatch>(cb.makeEmptyList());
						delete $1.id; delete $3;
					}
					|ID ASSIGN Exp SC {
						check(symtab.containsVar(*$1), output::errorUndef(yylineno, *$1));
						check(!symtab.isConst(*$1), output::errorConstMismatch(yylineno));
						checkMismatch($3->type, symtab.getVariableType(*$1));
						cb.emitStoreVar(*$1, $3);
						$$ = new std::vector<Backpatch>(cb.makeEmptyList());
						delete $1; delete $3;
					}
					|Call SC {
						$$ = new std::vector<Backpatch>(cb.makeEmptyList());
					}
					|RETURN {checkMismatch(VOID_EXP, symtab.getCurrentlyParsedFuncType().return_type);} SC {
						$$ = new std::vector<Backpatch>(cb.makeEmptyList());
					}
					|RETURN Exp {//TODO: cause 'RETURN' to actually return the appropriate register, with its real type (not raw data).
						//TODO: check edge case where this value (of Exp) is boolean...
						checkMismatch($2->type, symtab.getCurrentlyParsedFuncType().return_type);
						check($2->type != VOID_EXP, output::errorMismatch(yylineno));
					} SC {
						$$ = new std::vector<Backpatch>(cb.makeEmptyList());
						delete $2;
					}
					|BREAK SC {
						check(loop_depth!=0, output::errorUnexpectedBreak(yylineno));
						$$ = new std::vector<Backpatch>(cb.makeEmptyList());
					}
					|CONTINUE SC {
						check(loop_depth!=0, output::errorUnexpectedContinue(yylineno));
						$$ = new std::vector<Backpatch>(cb.makeEmptyList());
					}
					;
VarDecStart:		TypeAnnotation Type ID {
						check(symtab.declarableValidId(*$3), output::errorDef(yylineno, *$3));
						$$ = {.is_const = $1, .raw_type = $2, .id = $3};
					};

%%
void yyerror(const char* s){
	output::errorSyn(yylineno);
	exit(1);
}

void declareLibraryFuncs(){
	//FunctionType creates a shared pinter for these allocations:
	std::vector<Parameter>* print_params = new std::vector<Parameter>();
	std::vector<Parameter>* printi_params = new std::vector<Parameter>();

	//in print/i line of origin and is_const parameters are irrelevant, but have to be given some value:
	print_params->push_back(Parameter("str", STRING_EXP, 0, true));
	printi_params->push_back(Parameter("i", INT_EXP, 0, true));
	symtab.declareFunc("print", VOID_EXP, print_params);
	symtab.finishFunc(false);
	symtab.declareFunc("printi", VOID_EXP, printi_params);
	symtab.finishFunc(false);
	
}

void emitTmpMainStart(){
	cb.emit("define i32 @main(){");
}
void emitTmpMainEnd(){
	cb.emit("ret i32 0");
	cb.emit("}");
}

int main(){
	#ifdef MYDB
		yydebug = 1;
	#endif
	symtab = SimpleSymtab();
	declareLibraryFuncs();
	#ifdef OLDT
	#else
	cb.emitLibFuncs();
	emitTmpMainStart();
	#endif

	loop_depth = 0;
	yyparse();
	
	checkMainMissing();
	#ifdef OLDT
	output::endScope();//this is the global scope.
	symtab.printFuncDecls();
	#else
	cb.printGlobalBuffer();
	emitTmpMainEnd();
	cb.printCodeBuffer();
	#endif

	return 0;
}